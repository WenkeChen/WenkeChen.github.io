---
title: "八股用时方恨少 - Go垃圾回收"
date: 2024-04-03T13:05:55+08:00
draft: false
---

### Go用的是什么GC方式是什么，有什么特点？

Go使用的是追踪式GC，三色标记法。从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。

特点：

- 无分代：对象没有代际之分
- 不整理：回收过程中不对对象进行移动与整理
- 并发：GC与用户代码并发执行

### 什么是根对象

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：

1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

### 三色标记法是什么

从垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象：

- 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束时白色对象会被回收
- 灰色对象（波面）：已被回收器访问到的对象，但回收器还要对其中的一个或多个指针进行扫描，因为他们还可能指向白色对象
- 黑色对象（确定存活）：已被回收器访问到的对象，黑色对象中任何一个指针都不可能直接指向白色对象

### STW是什么意思

STW 在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图的一段过程

### 有了GC，为什么还会发生内存泄漏

1. 预期能被快速释放的内存因被根对象引用而没有得到迅速释放，如用全局变量做缓存
2. goroutine泄漏，如不加限制地创建goroutine

### 逃逸分析是怎么进行的

Go语言逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。

编译器会根据变量是否被外部引用来决定是否逃逸：

1. 如果函数外部没有引用，则优先放到栈中；
2. 如果函数外部存在引用，则必定放到堆中；

逃逸分析这种“骚操作”把变量合理地分配到它该去的地方。即使你是用new申请到的内存，如果我发现你竟然在退出函数后没有用了，那么就把你丢到栈上，毕竟栈上的内存分配比堆上快很多；反之，即使你表面上只是一个普通的变量，但是经过逃逸分析后发现在退出函数之后还有其他地方在引用，那我就把你分配到堆上。

如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销（占用CPU容量的25%）。

堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。

通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少GC的压力，提高程序的运行速度。

### 如何进行GC调优

1. 合理化内存分配的速度、提高赋值器的 CPU 利用率

例：控制goroutine的创建速度

2. 降低并复用已经申请的内存

例：sync.Pool，复用申请的内存

3. 调整GOGC

例：将GOGC阈值调高，降低GC频率

4.  其他

例：字符串拼接用strings.Builder





