<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>golang热加载及代码调试 | wenkechen</title><meta name=keywords content="IDEA,Goland,debug"><meta name=description content="热加载 为什么需要热加载 在编写go程序的过程中，每次修改完代码我们都得重新编译运行它，这是一个重复且麻烦的过程。那么有没有什么方法可以免去这个步骤，使得每次我们修改完代码自动编译并运行程序呢？
实现 这里要介绍一个用专门用于热加载golang程序的包 air
安装 $ go install github.com/cosmtrek/air@latest 使用  进入项目目录 初始化配置文件  $ air init 修改配置文件 实例文件  # Config file for [Air](https://github.com/cosmtrek/air) in TOML format  # 工作目录 # .或者绝对路径，注意下面的路径必须是相对于根路径的 root = &#34;.&#34; tmp_dir = &#34;tmp&#34;  [build]  # 老的shell命令，也可以使用`make`  cmd = &#34;go build -o ./tmp/main .&#34;  # 从`cmd`产生的二进制文件.  bin = &#34;tmp/main&#34;  # 自定义编译二进制文件，可以在运行命令的时候设置环境变量  full_bin = &#34;APP_ENV=dev APP_USER=air ./tmp/main&#34;  # 监视扩展名为以下类型的文件  include_ext = [&#34;go&#34;, &#34;tpl&#34;, &#34;tmpl&#34;, &#34;html&#34;]  # 忽略以下目录下的文件修改  exclude_dir = [&#34;assets&#34;, &#34;tmp&#34;, &#34;vendor&#34;, &#34;frontend/node_modules&#34;]  # 监视这些目录下文件的修改  include_dir = []  # 忽略以下文件  exclude_file = []  # 排除符合以下正则表达式的文件  exclude_regex = [&#34;_test."><meta name=author content="WenkeChen"><link rel=canonical href=https://wenkechen.github.io/posts/golang%E7%83%AD%E5%8A%A0%E8%BD%BD%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/><meta name=google-site-verification content="5qPbseAOG3zr_auAjX6vFWkZZaOjD409lzGZUNlgKjo"><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ae01.alicdn.com/kf/H316b426e16a44015b29c0a8faf8e6ba3P.png><link rel=icon type=image/png sizes=16x16 href=https://wenkechen.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://wenkechen.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://wenkechen.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wenkechen.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.96.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZLVK1276CF"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZLVK1276CF",{anonymize_ip:!1})}</script><meta property="og:title" content="golang热加载及代码调试"><meta property="og:description" content="热加载 为什么需要热加载 在编写go程序的过程中，每次修改完代码我们都得重新编译运行它，这是一个重复且麻烦的过程。那么有没有什么方法可以免去这个步骤，使得每次我们修改完代码自动编译并运行程序呢？
实现 这里要介绍一个用专门用于热加载golang程序的包 air
安装 $ go install github.com/cosmtrek/air@latest 使用  进入项目目录 初始化配置文件  $ air init 修改配置文件 实例文件  # Config file for [Air](https://github.com/cosmtrek/air) in TOML format  # 工作目录 # .或者绝对路径，注意下面的路径必须是相对于根路径的 root = &#34;.&#34; tmp_dir = &#34;tmp&#34;  [build]  # 老的shell命令，也可以使用`make`  cmd = &#34;go build -o ./tmp/main .&#34;  # 从`cmd`产生的二进制文件.  bin = &#34;tmp/main&#34;  # 自定义编译二进制文件，可以在运行命令的时候设置环境变量  full_bin = &#34;APP_ENV=dev APP_USER=air ./tmp/main&#34;  # 监视扩展名为以下类型的文件  include_ext = [&#34;go&#34;, &#34;tpl&#34;, &#34;tmpl&#34;, &#34;html&#34;]  # 忽略以下目录下的文件修改  exclude_dir = [&#34;assets&#34;, &#34;tmp&#34;, &#34;vendor&#34;, &#34;frontend/node_modules&#34;]  # 监视这些目录下文件的修改  include_dir = []  # 忽略以下文件  exclude_file = []  # 排除符合以下正则表达式的文件  exclude_regex = [&#34;_test."><meta property="og:type" content="article"><meta property="og:url" content="https://wenkechen.github.io/posts/golang%E7%83%AD%E5%8A%A0%E8%BD%BD%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"><meta property="og:image" content="https://wenkechen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-27T19:38:07+08:00"><meta property="article:modified_time" content="2022-03-27T19:38:07+08:00"><meta property="og:site_name" content="WenkeChen"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wenkechen.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="golang热加载及代码调试"><meta name=twitter:description content="热加载 为什么需要热加载 在编写go程序的过程中，每次修改完代码我们都得重新编译运行它，这是一个重复且麻烦的过程。那么有没有什么方法可以免去这个步骤，使得每次我们修改完代码自动编译并运行程序呢？
实现 这里要介绍一个用专门用于热加载golang程序的包 air
安装 $ go install github.com/cosmtrek/air@latest 使用  进入项目目录 初始化配置文件  $ air init 修改配置文件 实例文件  # Config file for [Air](https://github.com/cosmtrek/air) in TOML format  # 工作目录 # .或者绝对路径，注意下面的路径必须是相对于根路径的 root = &#34;.&#34; tmp_dir = &#34;tmp&#34;  [build]  # 老的shell命令，也可以使用`make`  cmd = &#34;go build -o ./tmp/main .&#34;  # 从`cmd`产生的二进制文件.  bin = &#34;tmp/main&#34;  # 自定义编译二进制文件，可以在运行命令的时候设置环境变量  full_bin = &#34;APP_ENV=dev APP_USER=air ./tmp/main&#34;  # 监视扩展名为以下类型的文件  include_ext = [&#34;go&#34;, &#34;tpl&#34;, &#34;tmpl&#34;, &#34;html&#34;]  # 忽略以下目录下的文件修改  exclude_dir = [&#34;assets&#34;, &#34;tmp&#34;, &#34;vendor&#34;, &#34;frontend/node_modules&#34;]  # 监视这些目录下文件的修改  include_dir = []  # 忽略以下文件  exclude_file = []  # 排除符合以下正则表达式的文件  exclude_regex = [&#34;_test."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://wenkechen.github.io/posts/"},{"@type":"ListItem","position":3,"name":"golang热加载及代码调试","item":"https://wenkechen.github.io/posts/golang%E7%83%AD%E5%8A%A0%E8%BD%BD%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang热加载及代码调试","name":"golang热加载及代码调试","description":"热加载 为什么需要热加载 在编写go程序的过程中，每次修改完代码我们都得重新编译运行它，这是一个重复且麻烦的过程。那么有没有什么方法可以免去这个步骤，使得每次我们修改完代码自动编译并运行程序呢？\n实现 这里要介绍一个用专门用于热加载golang程序的包 air\n安装 $ go install github.com/cosmtrek/air@latest 使用  进入项目目录 初始化配置文件  $ air init 修改配置文件 实例文件  # Config file for [Air](https://github.com/cosmtrek/air) in TOML format  # 工作目录 # .或者绝对路径，注意下面的路径必须是相对于根路径的 root = \u0026#34;.\u0026#34; tmp_dir = \u0026#34;tmp\u0026#34;  [build]  # 老的shell命令，也可以使用`make`  cmd = \u0026#34;go build -o ./tmp/main .\u0026#34;  # 从`cmd`产生的二进制文件.  bin = \u0026#34;tmp/main\u0026#34;  # 自定义编译二进制文件，可以在运行命令的时候设置环境变量  full_bin = \u0026#34;APP_ENV=dev APP_USER=air ./tmp/main\u0026#34;  # 监视扩展名为以下类型的文件  include_ext = [\u0026#34;go\u0026#34;, \u0026#34;tpl\u0026#34;, \u0026#34;tmpl\u0026#34;, \u0026#34;html\u0026#34;]  # 忽略以下目录下的文件修改  exclude_dir = [\u0026#34;assets\u0026#34;, \u0026#34;tmp\u0026#34;, \u0026#34;vendor\u0026#34;, \u0026#34;frontend/node_modules\u0026#34;]  # 监视这些目录下文件的修改  include_dir = []  # 忽略以下文件  exclude_file = []  # 排除符合以下正则表达式的文件  exclude_regex = [\u0026#34;_test.","keywords":["IDEA","Goland","debug"],"articleBody":"热加载 为什么需要热加载 在编写go程序的过程中，每次修改完代码我们都得重新编译运行它，这是一个重复且麻烦的过程。那么有没有什么方法可以免去这个步骤，使得每次我们修改完代码自动编译并运行程序呢？\n实现 这里要介绍一个用专门用于热加载golang程序的包 air\n安装 $ go install github.com/cosmtrek/air@latest 使用  进入项目目录 初始化配置文件  $ air init 修改配置文件 实例文件  # Config file for [Air](https://github.com/cosmtrek/air) in TOML format  # 工作目录 # .或者绝对路径，注意下面的路径必须是相对于根路径的 root = \".\" tmp_dir = \"tmp\"  [build]  # 老的shell命令，也可以使用`make`  cmd = \"go build -o ./tmp/main .\"  # 从`cmd`产生的二进制文件.  bin = \"tmp/main\"  # 自定义编译二进制文件，可以在运行命令的时候设置环境变量  full_bin = \"APP_ENV=dev APP_USER=air ./tmp/main\"  # 监视扩展名为以下类型的文件  include_ext = [\"go\", \"tpl\", \"tmpl\", \"html\"]  # 忽略以下目录下的文件修改  exclude_dir = [\"assets\", \"tmp\", \"vendor\", \"frontend/node_modules\"]  # 监视这些目录下文件的修改  include_dir = []  # 忽略以下文件  exclude_file = []  # 排除符合以下正则表达式的文件  exclude_regex = [\"_test.go\"]  # 排除未修改的文件  exclude_unchanged = true  # 遵循目录的符号链接  follow_symlink = true  # 日志文件，将放在上面指定的临时目录下  log = \"air.log\"  # 修改文件后重新编译的延迟时间（当文件修改太过频繁的时候不需要每次一修改完立马出发编译）  delay = 1000 # ms  # 当编译出错后停止运行原来的二进制文件  stop_on_error = true  # 在杀死进程之前发送中断信号（windows不支持这个特性）  send_interrupt = false  # 发送中断信号后延迟多少面查杀进程  kill_delay = 500 # ms  [log]  # 是否显示日志时间  time = false  [color]  # 自定义每个部分的颜色。如果颜色未定义，则使用程序的原始日志  main = \"magenta\"  watcher = \"cyan\"  build = \"yellow\"  runner = \"green\"  [misc]  # 是否在程序退出后删除临时目录  clean_on_exit = true 运行  使用默认路径./.air.toml\n$ air 指定.air.toml路径\n$ air -c ./.air.toml 向原程序传递参数\n# 等同于 ./tmp/main bench air bench  # 等同于 ./tmp/main server --port 8080 air server --port 8080 调试 这里以goland为例，在goland中，如果我们想要开启断点调试，只需要配置右上角的debug按钮即可，但是在上面所说的热加载中如何开启呢？\n点击Run - Edit Configurations点击面板上左上角的+号，选择Go Remote并保存 按照提示\n 安装dlv  $ go install github.com/go-delve/delve/cmd/dlv@latest 稍微修改一下上面air的full_bin配置  合并编译和运行两个步骤\nfull_bin=\"dlv debug --listen=:2345 --headless --api-version=2 --check-go-version=false --only-same-user=false --continue --accept-multiclient --output=./bin/server ./cmd/server/main.go\" 运行air  $ air 选在刚才的配置，点击debug按钮  Enjoy!\n","wordCount":"213","inLanguage":"en","datePublished":"2022-03-27T19:38:07+08:00","dateModified":"2022-03-27T19:38:07+08:00","author":{"@type":"Person","name":"WenkeChen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wenkechen.github.io/posts/golang%E7%83%AD%E5%8A%A0%E8%BD%BD%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"},"publisher":{"@type":"Organization","name":"wenkechen","logo":{"@type":"ImageObject","url":"https://ae01.alicdn.com/kf/H316b426e16a44015b29c0a8faf8e6ba3P.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wenkechen.github.io accesskey=h title="Wenke (Alt + H)">Wenke</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://wenkechen.github.io/ title=home><span>home</span></a></li><li><a href=https://wenkechen.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://wenkechen.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wenkechen.github.io>Home</a>&nbsp;»&nbsp;<a href=https://wenkechen.github.io/posts/>Posts</a></div><h1 class=post-title>golang热加载及代码调试</h1><div class=post-meta><span title="2022-03-27 19:38:07 +0800 +0800">March 27, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;WenkeChen&nbsp;|&nbsp;<a href=https://github.com/wenkechen/wenkechen.github.io/blob/master/content/posts/golang%e7%83%ad%e5%8a%a0%e8%bd%bd%e5%8f%8a%e4%bb%a3%e7%a0%81%e8%b0%83%e8%af%95.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%83%ad%e5%8a%a0%e8%bd%bd aria-label=热加载>热加载</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e7%83%ad%e5%8a%a0%e8%bd%bd aria-label=为什么需要热加载>为什么需要热加载</a></li><li><a href=#%e5%ae%9e%e7%8e%b0 aria-label=实现>实现</a><ul><li><a href=#%e5%ae%89%e8%a3%85 aria-label=安装>安装</a></li><li><a href=#%e4%bd%bf%e7%94%a8 aria-label=使用>使用</a></li></ul></li></ul></li><li><a href=#%e8%b0%83%e8%af%95 aria-label=调试>调试</a></li></ul></div></details></div><div class=post-content><h2 id=热加载>热加载<a hidden class=anchor aria-hidden=true href=#热加载>#</a></h2><h3 id=为什么需要热加载>为什么需要热加载<a hidden class=anchor aria-hidden=true href=#为什么需要热加载>#</a></h3><p>在编写go程序的过程中，每次修改完代码我们都得重新编译运行它，这是一个重复且麻烦的过程。那么有没有什么方法可以免去这个步骤，使得每次我们修改完代码自动编译并运行程序呢？</p><h3 id=实现>实现<a hidden class=anchor aria-hidden=true href=#实现>#</a></h3><p>这里要介绍一个用专门用于热加载golang程序的包 <a href=https://github.com/cosmtrek/air>air</a></p><h4 id=安装>安装<a hidden class=anchor aria-hidden=true href=#安装>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ go install github.com/cosmtrek/air@latest
</span></span></code></pre></div><h4 id=使用>使用<a hidden class=anchor aria-hidden=true href=#使用>#</a></h4><ol><li>进入项目目录</li><li>初始化配置文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ air init
</span></span></code></pre></div><ol start=3><li>修改配置文件
实例文件</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#75715e># Config file for [Air](https://github.com/cosmtrek/air) in TOML format</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 工作目录</span>
</span></span><span style=display:flex><span><span style=color:#75715e># .或者绝对路径，注意下面的路径必须是相对于根路径的</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>root</span> = <span style=color:#e6db74>&#34;.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>tmp_dir</span> = <span style=color:#e6db74>&#34;tmp&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>build</span>]
</span></span><span style=display:flex><span>  <span style=color:#75715e># 老的shell命令，也可以使用`make`</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>cmd</span> = <span style=color:#e6db74>&#34;go build -o ./tmp/main .&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 从`cmd`产生的二进制文件.</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>bin</span> = <span style=color:#e6db74>&#34;tmp/main&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 自定义编译二进制文件，可以在运行命令的时候设置环境变量</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>full_bin</span> = <span style=color:#e6db74>&#34;APP_ENV=dev APP_USER=air ./tmp/main&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 监视扩展名为以下类型的文件</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>include_ext</span> = [<span style=color:#e6db74>&#34;go&#34;</span>, <span style=color:#e6db74>&#34;tpl&#34;</span>, <span style=color:#e6db74>&#34;tmpl&#34;</span>, <span style=color:#e6db74>&#34;html&#34;</span>]
</span></span><span style=display:flex><span>  <span style=color:#75715e># 忽略以下目录下的文件修改</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exclude_dir</span> = [<span style=color:#e6db74>&#34;assets&#34;</span>, <span style=color:#e6db74>&#34;tmp&#34;</span>, <span style=color:#e6db74>&#34;vendor&#34;</span>, <span style=color:#e6db74>&#34;frontend/node_modules&#34;</span>]
</span></span><span style=display:flex><span>  <span style=color:#75715e># 监视这些目录下文件的修改</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>include_dir</span> = []
</span></span><span style=display:flex><span>  <span style=color:#75715e># 忽略以下文件</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exclude_file</span> = []
</span></span><span style=display:flex><span>  <span style=color:#75715e># 排除符合以下正则表达式的文件</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exclude_regex</span> = [<span style=color:#e6db74>&#34;_test.go&#34;</span>]
</span></span><span style=display:flex><span>  <span style=color:#75715e># 排除未修改的文件</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>exclude_unchanged</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 遵循目录的符号链接</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>follow_symlink</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 日志文件，将放在上面指定的临时目录下</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>log</span> = <span style=color:#e6db74>&#34;air.log&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 修改文件后重新编译的延迟时间（当文件修改太过频繁的时候不需要每次一修改完立马出发编译）</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>delay</span> = <span style=color:#ae81ff>1000</span> <span style=color:#75715e># ms</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 当编译出错后停止运行原来的二进制文件</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>stop_on_error</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 在杀死进程之前发送中断信号（windows不支持这个特性）</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>send_interrupt</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 发送中断信号后延迟多少面查杀进程</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>kill_delay</span> = <span style=color:#ae81ff>500</span> <span style=color:#75715e># ms</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>log</span>]
</span></span><span style=display:flex><span>  <span style=color:#75715e># 是否显示日志时间</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>time</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>color</span>]
</span></span><span style=display:flex><span>  <span style=color:#75715e># 自定义每个部分的颜色。如果颜色未定义，则使用程序的原始日志</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>main</span> = <span style=color:#e6db74>&#34;magenta&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>watcher</span> = <span style=color:#e6db74>&#34;cyan&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>build</span> = <span style=color:#e6db74>&#34;yellow&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>runner</span> = <span style=color:#e6db74>&#34;green&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#a6e22e>misc</span>]
</span></span><span style=display:flex><span>  <span style=color:#75715e># 是否在程序退出后删除临时目录</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>clean_on_exit</span> = <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><ol start=4><li>运行</li></ol><p>使用默认路径<code>./.air.toml</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ air
</span></span></code></pre></div><p>指定.air.toml路径</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ air -c ./.air.toml
</span></span></code></pre></div><p>向原程序传递参数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 等同于 ./tmp/main bench</span>
</span></span><span style=display:flex><span>air bench
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 等同于 ./tmp/main server --port 8080</span>
</span></span><span style=display:flex><span>air server --port <span style=color:#ae81ff>8080</span>
</span></span></code></pre></div><h2 id=调试>调试<a hidden class=anchor aria-hidden=true href=#调试>#</a></h2><p>这里以goland为例，在goland中，如果我们想要开启断点调试，只需要配置右上角的debug按钮即可，但是在上面所说的热加载中如何开启呢？</p><p>点击Run -> Edit Configurations点击面板上左上角的+号，选择Go Remote并保存
<img loading=lazy src=/images/go_remote.png alt=img.png></p><p>按照提示</p><ol><li>安装dlv</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ go install github.com/go-delve/delve/cmd/dlv@latest
</span></span></code></pre></div><ol start=2><li>稍微修改一下上面air的full_bin配置</li></ol><p>合并编译和运行两个步骤</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#a6e22e>full_bin</span>=<span style=color:#e6db74>&#34;dlv debug --listen=:2345 --headless --api-version=2 --check-go-version=false --only-same-user=false --continue --accept-multiclient --output=./bin/server ./cmd/server/main.go&#34;</span>
</span></span></code></pre></div><ol start=3><li>运行air</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ air
</span></span></code></pre></div><ol start=4><li>选在刚才的配置，点击debug按钮</li></ol><p>Enjoy!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wenkechen.github.io/tags/idea/>IDEA</a></li><li><a href=https://wenkechen.github.io/tags/goland/>Goland</a></li><li><a href=https://wenkechen.github.io/tags/debug/>debug</a></li></ul><nav class=paginav><a class=next href=https://wenkechen.github.io/posts/sort.sort%E6%BA%90%E7%A0%81/><span class=title>Next Page »</span><br><span>Golang排序</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://wenkechen.github.io>wenkechen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>